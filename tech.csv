name,ring,quadrant,isNew,description
Cypress,adopt,tools,TRUE,"<p>We keep receiving positive feedback on ""post-Selenium"" web UI testing tools such as <strong><a href=""http://www.cypress.io/"">Cypress</a></strong>, <a href=""/radar/tools/testcafe"">TestCafe</a> and <a href=""/radar/languages-and-frameworks/puppeteer"">Puppeteer</a>. Running end-to-end tests can present challenges, such as the long duration of the running process, the flakiness of some tests and the challenges of fixing failures in CI when running tests in headless mode. Our teams have had very good experiences with Cypress by solving common issues such as lack of performance and long wait time for responses and resources to load. Cypress has become the tool of choice for end-to-end testing within our teams.</p>"
Terratest,assess,tools,TRUE,"<p>We widely use <a href=""/radar/tools/terraform"">Terraform</a> as code to configure a cloud infrastructure. <strong><a href=""https://github.com/gruntwork-io/terratest"">Terratest</a></strong> is a Golang library that makes it easier to write automated tests for infrastructure code. A test run creates real infrastructure components (such as servers, firewalls or load balancers), deploys applications on them and validates the expected behavior using Terratest. At the end of the test, Terratest can undeploy the apps and clean up resources. This makes it largely useful for end-to-end tests of your infrastructure in a real environment.</p>"
Handwritten CloudFormation,hold,tools,TRUE,"<p><a href=""https://aws.amazon.com/cloudformation/"">AWS CloudFormation</a> is a proprietary declarative language to provision AWS infrastructure as code. Handwriting CloudFormation files is often a default approach to bootstrap AWS infrastructure automation. Although this might be a sensible way to start a small project, our teams, and the industry at large, have found that <strong>handwritten CloudFormation</strong> simply does not scale as the infrastructure grows. Noticeable pitfalls of handwritten CloudFormation files for large projects include poor readability, lack of imperative constructs, limited parameter definition and usage, and lack of type checking. Addressing these shortfalls has led to a rich ecosystem of both open-source and custom tooling. We find <a href=""/radar/tools/terraform"">Terraform</a> a sensible default that not only addresses shortfalls of CloudFormation but also has an active community to add the latest AWS features and fix bugs. In addition to Terraform, you can choose from many other tools and languages, including <a href=""/radar/languages-and-frameworks/troposphere"">troposphere</a>, <a href=""https://github.com/cloudreach/sceptre"">sceptre</a>, <a href=""https://github.com/capitalone/stack-deployment-tool"">Stack Deployment Tool</a> and <a href=""/radar/platforms/pulumi"">Pulumi</a>.</p>"
Apollo,adopt,language-and-frameworks,TRUE,"<p>Our teams report that <strong><a href=""http://www.apollographql.com/client"">Apollo</a></strong> has become the library of choice when building a <a href=""/radar/languages-and-frameworks/react-js"">React</a> application that uses GraphQL to access data from a <a href=""/radar/techniques/bff-backend-for-frontends"">back-end</a> service. Although the Apollo project also provides a server framework and a GraphQL gateway, the Apollo client gets our attention because it simplifies the problem of binding UI components to data served by any GraphQL backend. Put simply, this means less code needs to be written than using REST backends and redux.</p>"
MockK,adopt,language-and-frameworks,TRUE,"<p><strong><a href=""https://mockk.io"">MockK</a></strong> is our go-to tool for mocks when writing tests for <a href=""/radar/languages-and-frameworks/kotlin"">Kotlin</a> applications. We like to use this library because of its first-class support for Kotlin language features such as <a href=""https://kotlinlang.org/docs/reference/coroutines-overview.html"">coroutines</a> or lambda blocks. As a native library, it helps our teams to write clean and concise code on testing Kotlin applications instead of using the inconvenient wrappers of Mockito or PowerMock.</p>"
TypeScript,adopt,language-and-frameworks,TRUE,"<p><strong><a href=""https://www.typescriptlang.org/"">TypeScript</a></strong>, a statically typed language and superset of JavaScript, has become our sensible default. Large-scale projects benefit most from the type safety. Our developers favor its minimal configuration management, well-integrated IDE support and its ability to refactor code safely and gradually adopt types. With its <a href=""https://definitelytyped.org/"">good repository</a> of TypeScript-type definitions at hand, we benefit from all the rich JavaScript libraries while gaining type safety.</p>"
Vapor,assess,language-and-frameworks,TRUE,"<p>We're strong proponents of <a href=""/radar/techniques/polyglot-programming"">polyglot programming</a> but recognize that in some cases it can make sense to focus on a single programming language. If you're heavily invested in Swift, most likely because of iOS development, and you find yourself looking for a technology to write server-side services, have a look at <strong><a href=""https://vapor.codes/"">Vapor</a></strong>, a modern web framework for Swift that has gained a fair amount of popularity.</p>"
Contentful,adopt,platforms,TRUE,"<p>Headless content management systems (CMSes) are becoming a common component of digital platforms. <a href=""http://www.contentful.com/""><strong>Contentful</strong></a> is a modern headless CMS that our teams have successfully integrated into their development workflows. We particularly like its API-first approach and implementation of <a href=""http://www.contentful.com/r/knowledgebase/cms-as-code/"">CMS as code</a>. It supports powerful content modeling primitives as code and content model evolution scripts, which allow it to be treated like other data store schemas and enable <a href=""http://martinfowler.com/articles/evodb.html"">evolutionary database design</a> practices to be applied to CMS development. Its robustness and a stream of new features, including a sandbox environment, have impressed our teams further and made Contentful our default choice in this space.</p>"
AWS Fargate,trial,platforms,TRUE,"<p><strong><a href=""http://aws.amazon.com/fargate/"">AWS Fargate</a></strong>, the docker-as-a-service option on <a href=""/radar/platforms/aws"">AWS</a>, is now widely available across regions. It's a great solution for situations in which teams want to run Docker containers, because <a href=""/radar/platforms/aws-lambda"">AWS Lambda</a> functions aren't powerful enough, without having to manage EC2 instances or Kubernetes clusters. Our teams report generally positive experiences with Fargate; however, the convenience of this managed service can come at a cost, in financial terms.</p>"
TimescaleDB,assess,platforms,TRUE,"<p>In previous Radars we've discussed <a href=""/radar/platforms/postgresql-for-nosql"">PostgreSQL for NoSQL</a>. PostgreSQL's maturity and extensibility have led to a steady stream of innovative persistence stores built on the Postgres engine. One that caught our attention is <strong><a href=""https://www.timescale.com/"">TimescaleDB</a></strong>, a database that allows fast writes and optimized queries over time-series data. Albeit not (yet) as full-featured as <a href=""/radar/platforms/influxdb"">InfluxDB</a>, TimescaleDB offers an alternative data model and querying capability. You should evaluate TimescaleDB if you have modest scalability needs, prefer to use SQL and appreciate the stability and familiar administrative interface that PostgreSQL offers.</p>"
Four key metrics,adopt,techniques,TRUE,"<p>The thorough <a href=""https://devops-research.com/research.html"">State of DevOps</a> reports have focused on data-driven and statistical analysis of high-performing organizations. The result of this multiyear research, published in <a href=""https://itrevolution.com/book/accelerate/"">Accelerate</a>, demonstrates a direct link between organizational performance and software delivery performance. The researchers have determined that only <strong>four key metrics</strong> differentiate between low, medium and high performers: lead time, deployment frequency, mean time to restore (MTTR) and change fail percentage. Indeed, we've found that these four key metrics are a simple and yet powerful tool to help leaders and teams focus on measuring and improving what matters. A good place to start is to instrument the build pipelines so you can capture the four key metrics and make the software delivery value stream visible. <a href=""https://www.gocd.org/"">GoCD pipelines,</a> for example, provide the ability to measure these four key metrics as a first-class citizen of the <a href=""https://www.gocd.org/analytics.html"">GoCD analytics</a>.</p>"
